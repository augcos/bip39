package bip39

import (
	"math"
	"bytes"
	"errors"
	"strings"
	"math/big"
	"crypto/rand"
	"crypto/sha256"
	"crypto/sha512"
	
	"golang.org/x/crypto/pbkdf2"
	"github.com/augcos/bip39/wordlists"
)

/************************************************* Package variables **************************************************/

var (
	// Default wordlist is in English
	wordList = wordlists.English
	maskShiftWord = big.NewInt(2048)

	// Eror messages
	invalidBitSize = errors.New("Invalid bit size. Bit size must be between 128 and 256 and be a multiple of 32")
	invalidMnemonicSize = errors.New("Invalid mnemonic size")
	invalidChecksum = errors.New("Invalid checksum")
	readerEntropyError = errors.New("Error reading the bits from the entropy generator")
	wordNotFoundError = errors.New("Error with the wordlist - word not found")
)


/*************************************************** Main Functions ***************************************************/

// SetWordList sets any given string slice as the word list for the mnemonic
func SetWordList(newList []string) {
	wordList = newList
}

// GenEntropy returns a new randomly generated byte slice with bitSize bits (must be between 128-256 and be a multiple 
// of 32) plus the checksum bits
func GenEntropy(bitSize int) ([]byte, error){
	// we validate the bitSize
	if err := checkValidBitSize(bitSize); err!=nil {
		return nil, err
	}

	// bytes are read from the random generator
	entropy := make([]byte, bitSize/8)
	_, err := rand.Read(entropy)
	if err!=nil {
		return nil, readerEntropyError
	}

	// we add the checksum to the entropy
	entropy, _ = AddChecksum(entropy)

	return entropy, nil
}

// GetMnemonicFromEntropy takes the entropy byte slice and returns the corresponding mnemonic as a string slice
func GetMnemonicFromEntropy(entropy []byte) ([]string, error) {	
	// we remove the checksum byte before validating the bit size
	bitSize := len(entropy)*8
	if err:=checkValidBitSize(bitSize-8); err!=nil {
		return nil, err
	}
	if err:=checkValidChecksum(entropy); err!=nil {
		return nil, err
	}

	numberWords := bitSize/11		// the number of words is the floor of bitSize/11
	maskWord := big.NewInt(2047)	// mask for the first 11 bits
	numWord := big.NewInt(0)		// empty big int for computing the word indices
	
	// mnemonic is constructed from the entropy and wordlist
	mnemonic := make([]string,numberWords)
	entropyBigInt := new(big.Int).SetBytes(entropy)
	for i:=0; i<numberWords; i++ {
		// word index is computed
		numWord.And(entropyBigInt, maskWord)
		entropyBigInt.Div(entropyBigInt, maskShiftWord)
		// word is recovered from the wordlist and added to the mnemonic
		mnemonic[i] = wordList[numWord.Int64()]
	}

	// mnemonic order is inverted
	mnemonic = invertMnemonic(mnemonic)

	return mnemonic, nil
}


// GetEntropyFromMnemonic takes a mnemonic string slice and returns the corresponding entropy byte slice
func GetEntropyFromMnemonic(mnemonic []string) ([]byte, error) {
	// we validate the size of the mnemonic
	err := checkValidMnemonicSize(mnemonic)
	if err!=nil {
		return nil, err
	}

	// we invert the order of the mnemonic (most important bit first)
	mnemonic = invertMnemonic(mnemonic)

	// we go through the mnemonic and reconstruct the entropy byte array
	entropyBigInt := big.NewInt(0)	
	for idx, word := range(mnemonic) {
		// we get the index for each word
		index, err := getWordIndex(word)
		if err!=nil{
			return nil, err
		}
		// we add the index to the entropy
		wordBigInt := big.NewInt(int64(index))
		entropyBigInt.Add(entropyBigInt,wordBigInt)
		// we shift the entropy to leave space for the next word index
		if idx<(len(mnemonic)-1) {
			entropyBigInt.Mul(entropyBigInt,maskShiftWord)
		}
	}
	
	// we validate che checksum
	entropy := entropyBigInt.Bytes()
	if err:=checkValidChecksum(entropy); err!=nil {
		return nil, err
	}

	return entropy, nil
}

// GetSeedFromMnemonic takes a mnemonic string slice and a passphrase string and returns the 521-bit seed byte slice
func GetSeedFromMnemonic(mnemonic []string, passphrase string) ([]byte, error) {
	// we validate the size of the mnemonic
	err := checkValidMnemonicSize(mnemonic)
	if err!=nil {
		return nil, err
	}
	// mnemonic is joined in a single string
	mnemonicJoined := strings.Join(mnemonic, " ")
	// salt is created using the passphrase
	salt := "mnemonic" + passphrase

	// the seed is computed and returned
	return pbkdf2.Key([]byte(mnemonicJoined), []byte(salt), 2048, 64, sha512.New), nil
}


// AddChecksum takes an entropy byte slice and adds the first bit of its SHA-256 hash. This is meant to be called by the
// user only when manual addition of the checksum is needed (e.g. custom entropy generator).
func AddChecksum(entropy []byte) ([]byte, error) {
	// checksum is computed from the entropy
	checksum, checksumShiftMask, err := getChecksum(entropy)
	if err!=nil {
		return nil, err
	}

	// we shift the entropy to leave space for the checksum bits
	entropyBigInt := new(big.Int).SetBytes(entropy)
	entropyBigInt.Mul(entropyBigInt, checksumShiftMask)

	// we add the checksum to the shifted entropy
	entropyBigInt.Add(entropyBigInt, checksum)
	newEntropy := entropyBigInt.Bytes()
	
	// we pad with zeros to recover the original bitSize (plus checksum byte)
	paddedEntropy := zeroPadBytes(newEntropy, len(entropy) + 1)

	return paddedEntropy, nil
}




/************************** Utilities *****************************/

// getChecksum takes the entropy byte slice and returns its checksum as a big int its bit size
func getChecksum(entropy []byte) (*big.Int, *big.Int, error) {
	// we validate the bit size
	bitSize := len(entropy) * 8
	err := checkValidBitSize(bitSize)
	if err!=nil {
		return nil, nil, err
	}

	// we compute the sha256
	newSha256 := sha256.New()
	newSha256.Write(entropy)
	hash := newSha256.Sum(nil)
	checksum := new(big.Int).SetBytes(hash)

	// we iteratively shift the checksum variable until we are only left with the first bits
	checksumSize := bitSize/32
	checksumShiftMask := big.NewInt(int64(math.Pow(2,float64(checksumSize))))
	for i:=0; i<(256-checksumSize); i=i+checksumSize {
		if ((256-i)<2*checksumSize) {
			// if we're approaching the end, we only shift enough bits until we are left with the first bits
			bitsLeft := int64((256-checksumSize) - (i-checksumSize) - checksumSize)
			bitsLeftMask := big.NewInt(int64(math.Pow(2,(float64(bitsLeft)))))
			checksum.Div(checksum, bitsLeftMask)
		} else {
			// if there's still room, we shift checksumSize bits to the right
			checksum.Div(checksum, checksumShiftMask)
		}
	}

	// we return the checksum and its mask as big intss
	return checksum, checksumShiftMask, nil
}

// checkValidChecksum takes the entropy byte slice and returns an error if the checksum is not valid
func checkValidChecksum(entropy []byte) error {
	// we compute the bit size of the original entropy (without checksum) and of the checksum
	origBitSize := (len(entropy)-1)*8
	checksumSize := origBitSize/32
	inputEntropy := new(big.Int).SetBytes(entropy)
	
	// we create the mask for recovering the checksum and for shifting the entropy (checksumSize bits)
	checksumMask := big.NewInt(int64(math.Pow(2,float64(checksumSize))-1))
	checksumShiftMask := big.NewInt(int64(math.Pow(2,float64(checksumSize))))

	// we extract the checksum from the byte slice
	inputChecksum := big.NewInt(0)
	inputChecksum.And(inputEntropy, checksumMask)

	// we extract the original entropy from the byte slice
	inputEntropy.Div(inputEntropy, checksumShiftMask)
	inputEntropyBytes := zeroPadBytes(inputEntropy.Bytes(), origBitSize/8)

	// we compute the checksum for the entropy
	checksum, _, err := getChecksum(inputEntropyBytes)
	if err!=nil {
		return err
	}
	// we check that the computed checksum is identical to the one in the input
	if bytes.Compare(checksum.Bytes(), inputChecksum.Bytes())!=0 {
		return invalidChecksum
	}

	return nil
}


// checkValidBitSize returns an error if bitSize is not between 128 and 256 or if it is not a multiple of 32
func checkValidBitSize(bitSize int) error {
	if (bitSize%32!=0) || (bitSize<128) || (bitSize>256) { 
		return invalidBitSize
	}
	return nil
}


// checkValidMnemonicSize returns an error if the length of the mnemonic string slice is not valid (i.e. does not
// correspond to a valid entropy bit size)
func checkValidMnemonicSize(mnemonic []string) error {
	bitSize := len(mnemonic)*11		// the bitSize is 8 times the byte size of entropy
	// we remove the bits from the checksum before validating the bitSize
	if err:=checkValidBitSize(bitSize*32/33); err!=nil {
		return invalidMnemonicSize
	}
	return nil
}


// invertMnemonic reverses the order of the mnemonic string slice
func invertMnemonic(mnemonic []string) []string {
	for i, j := 0, len(mnemonic)-1; i < j; i, j = i+1, j-1 {
		mnemonic[i], mnemonic[j] = mnemonic[j], mnemonic[i]
	}
	return mnemonic
}


// getWordIndex returns the index of the input word in the wordlist. If it is not in the list, an error is returned
func getWordIndex(searchWord string) (int,error) {
	for index,word := range(wordList) {
		if word==searchWord {
			return index, nil
		}
	}
	return 0, wordNotFoundError
}


// zeroPadBytes pads a byte slice with additional zeros to reach the target size
func zeroPadBytes(input []byte, targetSize int) []byte {
	offset := targetSize - len(input)
	if offset <= 0 {
		return input
	}
	output := make([]byte, len(input) + offset)
	copy(output[offset:], input)
	return output
}